{"version":3,"file":"Analytics.js","sources":["../../../../src/core/Analytics/Analytics.ts"],"sourcesContent":["import { debounce } from '../../utils/debounce';\nimport { processAnalyticsData } from './utils';\nimport { AbstractAnalyticsEvent, AnalyticsEventCategory } from './events/AbstractAnalyticsEvent';\nimport Storage from '../../utils/Storage';\nimport { LIBRARY_BUNDLE_TYPE, LIBRARY_VERSION } from '../config';\nimport { AnalyticsEventQueue } from './AnalyticsEventQueue';\nimport type { AnalyticsOptions } from './types';\nimport type { AnalyticsEventPayload, IAnalyticsService, RequestAttemptIdPayload } from './AnalyticsService';\n\nexport interface AnalyticsProps {\n    service: IAnalyticsService;\n    eventQueue: AnalyticsEventQueue;\n    enabled?: boolean;\n    analyticsData?: AnalyticsOptions['analyticsData'];\n}\n\nexport interface IAnalytics {\n    setUp({ sessionId, checkoutStage, locale }: { sessionId?: string; checkoutStage?: 'precheckout' | 'checkout'; locale?: string }): Promise<void>;\n    sendFlavor(flavor: 'dropin' | 'components'): Promise<void>;\n    sendAnalytics(event: AbstractAnalyticsEvent): void;\n    flush(): void;\n}\n\nexport interface CheckoutAttemptIdSessionStorage {\n    id: string;\n    timestamp: number;\n}\n\n/**\n * If the checkout attempt ID was stored more than fifteen minutes ago, then we should request a new ID.\n * More here: COWEB-1099\n */\nfunction isSessionCreatedUnderFifteenMinutes(session: CheckoutAttemptIdSessionStorage): boolean {\n    const FIFTEEN_MINUTES_IN_MS = 15 * 60 * 1000;\n    if (!session?.timestamp) return false;\n    const fifteenMinutesAgo = Date.now() - FIFTEEN_MINUTES_IN_MS;\n    return session.timestamp > fifteenMinutesAgo;\n}\n\nconst ANALYTICS_INFO_DEBOUNCE_DELAY = process.env.NODE_ENV === 'development' ? 5_000 : 10_000;\nconst ANALYTICS_ERROR_AND_LOGS_DEBOUNCE_DELAY = 5_000;\n\nclass Analytics implements IAnalytics {\n    private readonly analyticsData?: AnalyticsOptions['analyticsData'];\n    private readonly service: IAnalyticsService;\n    private readonly eventsQueue: AnalyticsEventQueue;\n    private readonly storage = new Storage<CheckoutAttemptIdSessionStorage>('checkout-attempt-id', 'sessionStorage');\n    private readonly debouncedSendInfoEvents: () => void;\n    private readonly debouncedSendEvents: () => void;\n\n    private enabled: boolean = true;\n    private capturedCheckoutAttemptId?: string;\n    private isFlavorReported = false;\n\n    constructor({ service, eventQueue, enabled, analyticsData }: AnalyticsProps) {\n        this.service = service;\n        this.eventsQueue = eventQueue;\n\n        this.debouncedSendInfoEvents = debounce(this.sendEvents.bind(this), ANALYTICS_INFO_DEBOUNCE_DELAY);\n        this.debouncedSendEvents = debounce(this.sendEvents.bind(this), ANALYTICS_ERROR_AND_LOGS_DEBOUNCE_DELAY);\n\n        if (enabled !== undefined) this.enabled = enabled;\n        if (analyticsData) this.analyticsData = analyticsData;\n    }\n\n    public async setUp({\n        sessionId,\n        checkoutStage,\n        locale\n    }: { sessionId?: string; locale?: string; checkoutStage?: 'precheckout' | 'checkout' } = {}): Promise<void> {\n        try {\n            const checkoutAttemptIdSession = this.storage.get();\n            const isSessionReusable = isSessionCreatedUnderFifteenMinutes(checkoutAttemptIdSession);\n\n            const { applicationInfo, checkoutAttemptId: checkoutAttemptIdFromPayByLink } = processAnalyticsData(this.analyticsData);\n\n            const availableCheckoutAttemptId: string | undefined = isSessionReusable ? checkoutAttemptIdSession.id : checkoutAttemptIdFromPayByLink;\n\n            const payload: RequestAttemptIdPayload = {\n                version: LIBRARY_VERSION,\n                buildType: LIBRARY_BUNDLE_TYPE,\n                channel: 'Web',\n                platform: 'Web',\n                locale,\n                referrer: window.location.href,\n                screenWidth: window.screen.width,\n                checkoutStage: checkoutStage || 'checkout',\n                level: this.enabled ? 'all' : 'initial',\n                ...(applicationInfo && { applicationInfo }),\n                ...(sessionId && { sessionId }),\n                ...(availableCheckoutAttemptId && { checkoutAttemptId: availableCheckoutAttemptId })\n            };\n\n            this.capturedCheckoutAttemptId = await this.service.requestCheckoutAttemptId(payload);\n\n            this.storage.set({\n                id: this.capturedCheckoutAttemptId,\n                timestamp: isSessionReusable ? checkoutAttemptIdSession.timestamp : Date.now()\n            });\n        } catch (error: unknown) {\n            this.enabled = false;\n            console.warn('Analytics: Error setting up', error);\n        }\n    }\n\n    public sendAnalytics(event: AbstractAnalyticsEvent): void {\n        if (!this.enabled) {\n            return;\n        }\n\n        try {\n            this.addEventToQueue(event);\n        } catch (error: unknown) {\n            console.warn('Analytics: Error adding event to queue', error);\n        }\n    }\n\n    public async sendFlavor(flavor: 'dropin' | 'components'): Promise<void> {\n        if (!this.capturedCheckoutAttemptId) return;\n        if (this.isFlavorReported) return;\n\n        this.isFlavorReported = true;\n\n        try {\n            await this.service.reportIntegrationFlavor(flavor, this.capturedCheckoutAttemptId);\n        } catch (error) {\n            console.warn('Analytics: Error reporting flavor', error);\n        }\n    }\n\n    public flush(): void {\n        void this.sendEvents();\n    }\n\n    /**\n     * Info events don't have high priority, therefore  we add a delay in order to dispatch a batch of events\n     * Log/Error events are sent almost immediately. There is a debounce mechanism in place but the delay is very minimal\n     *\n     * @param event\n     * @private\n     */\n    private addEventToQueue(event: AbstractAnalyticsEvent): void {\n        this.eventsQueue.add(event);\n\n        if (event.getEventCategory() === AnalyticsEventCategory.info) {\n            this.debouncedSendInfoEvents();\n        } else {\n            this.debouncedSendEvents();\n        }\n    }\n\n    private async sendEvents(): Promise<void> {\n        if (!this.capturedCheckoutAttemptId || !this.enabled) {\n            return;\n        }\n\n        const payload: AnalyticsEventPayload = {\n            channel: 'Web',\n            platform: 'Web',\n            info: this.eventsQueue.infoEvents,\n            errors: this.eventsQueue.errorEvents,\n            logs: this.eventsQueue.logEvents\n        };\n\n        this.eventsQueue.clear();\n\n        try {\n            await this.service.sendEvents(payload, this.capturedCheckoutAttemptId);\n        } catch (error) {\n            console.warn('Analytics: Error sending events', error);\n        }\n    }\n}\n\nexport default Analytics;\n"],"names":["Analytics","setUp","sessionId","checkoutStage","locale","checkoutAttemptIdSession","this","storage","get","isSessionReusable","session","timestamp","fifteenMinutesAgo","Date","now","isSessionCreatedUnderFifteenMinutes","applicationInfo","checkoutAttemptId","checkoutAttemptIdFromPayByLink","processAnalyticsData","analyticsData","availableCheckoutAttemptId","id","payload","_object_spread","version","LIBRARY_VERSION","buildType","LIBRARY_BUNDLE_TYPE","channel","platform","referrer","window","location","href","screenWidth","screen","width","level","enabled","capturedCheckoutAttemptId","service","requestCheckoutAttemptId","set","error","console","warn","sendAnalytics","event","addEventToQueue","sendFlavor","flavor","isFlavorReported","reportIntegrationFlavor","flush","sendEvents","eventsQueue","add","getEventCategory","AnalyticsEventCategory","info","debouncedSendInfoEvents","debouncedSendEvents","infoEvents","errors","errorEvents","logs","logEvents","clear","constructor","eventQueue","_define_property","Storage","debounce","bind","undefined"],"mappings":"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"}