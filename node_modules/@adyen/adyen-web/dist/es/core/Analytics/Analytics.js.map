{"version":3,"file":"Analytics.js","sources":["../../../../src/core/Analytics/Analytics.ts"],"sourcesContent":["import { debounce } from '../../utils/debounce';\nimport { processAnalyticsData } from './utils';\nimport { AbstractAnalyticsEvent, AnalyticsEventCategory } from './events/AbstractAnalyticsEvent';\nimport Storage from '../../utils/Storage';\nimport { LIBRARY_BUNDLE_TYPE, LIBRARY_VERSION } from '../config';\nimport { AnalyticsEventQueue } from './AnalyticsEventQueue';\nimport type { AnalyticsOptions } from './types';\nimport type { AnalyticsEventPayload, IAnalyticsService, RequestAttemptIdPayload } from './AnalyticsService';\n\nexport interface AnalyticsProps {\n    service: IAnalyticsService;\n    eventQueue: AnalyticsEventQueue;\n    enabled?: boolean;\n    analyticsData?: AnalyticsOptions['analyticsData'];\n}\n\nexport interface IAnalytics {\n    setUp({ sessionId, checkoutStage, locale }: { sessionId?: string; checkoutStage?: 'precheckout' | 'checkout'; locale?: string }): Promise<void>;\n    sendFlavor(flavor: 'dropin' | 'components'): Promise<void>;\n    sendAnalytics(event: AbstractAnalyticsEvent): void;\n    flush(): void;\n}\n\nexport interface CheckoutAttemptIdSessionStorage {\n    id: string;\n    timestamp: number;\n}\n\n/**\n * If the checkout attempt ID was stored more than fifteen minutes ago, then we should request a new ID.\n * More here: COWEB-1099\n */\nfunction isSessionCreatedUnderFifteenMinutes(session: CheckoutAttemptIdSessionStorage): boolean {\n    const FIFTEEN_MINUTES_IN_MS = 15 * 60 * 1000;\n    if (!session?.timestamp) return false;\n    const fifteenMinutesAgo = Date.now() - FIFTEEN_MINUTES_IN_MS;\n    return session.timestamp > fifteenMinutesAgo;\n}\n\nconst ANALYTICS_INFO_DEBOUNCE_DELAY = process.env.NODE_ENV === 'development' ? 5_000 : 10_000;\nconst ANALYTICS_ERROR_AND_LOGS_DEBOUNCE_DELAY = 5_000;\n\nclass Analytics implements IAnalytics {\n    private readonly analyticsData?: AnalyticsOptions['analyticsData'];\n    private readonly service: IAnalyticsService;\n    private readonly eventsQueue: AnalyticsEventQueue;\n    private readonly storage = new Storage<CheckoutAttemptIdSessionStorage>('checkout-attempt-id', 'sessionStorage');\n    private readonly debouncedSendInfoEvents: () => void;\n    private readonly debouncedSendEvents: () => void;\n\n    private enabled: boolean = true;\n    private capturedCheckoutAttemptId?: string;\n    private isFlavorReported = false;\n\n    constructor({ service, eventQueue, enabled, analyticsData }: AnalyticsProps) {\n        this.service = service;\n        this.eventsQueue = eventQueue;\n\n        this.debouncedSendInfoEvents = debounce(this.sendEvents.bind(this), ANALYTICS_INFO_DEBOUNCE_DELAY);\n        this.debouncedSendEvents = debounce(this.sendEvents.bind(this), ANALYTICS_ERROR_AND_LOGS_DEBOUNCE_DELAY);\n\n        if (enabled !== undefined) this.enabled = enabled;\n        if (analyticsData) this.analyticsData = analyticsData;\n    }\n\n    public async setUp({\n        sessionId,\n        checkoutStage,\n        locale\n    }: { sessionId?: string; locale?: string; checkoutStage?: 'precheckout' | 'checkout' } = {}): Promise<void> {\n        try {\n            const checkoutAttemptIdSession = this.storage.get();\n            const isSessionReusable = isSessionCreatedUnderFifteenMinutes(checkoutAttemptIdSession);\n\n            const { applicationInfo, checkoutAttemptId: checkoutAttemptIdFromPayByLink } = processAnalyticsData(this.analyticsData);\n\n            const availableCheckoutAttemptId: string | undefined = isSessionReusable ? checkoutAttemptIdSession.id : checkoutAttemptIdFromPayByLink;\n\n            const payload: RequestAttemptIdPayload = {\n                version: LIBRARY_VERSION,\n                buildType: LIBRARY_BUNDLE_TYPE,\n                channel: 'Web',\n                platform: 'Web',\n                locale,\n                referrer: window.location.href,\n                screenWidth: window.screen.width,\n                checkoutStage: checkoutStage || 'checkout',\n                level: this.enabled ? 'all' : 'initial',\n                ...(applicationInfo && { applicationInfo }),\n                ...(sessionId && { sessionId }),\n                ...(availableCheckoutAttemptId && { checkoutAttemptId: availableCheckoutAttemptId })\n            };\n\n            this.capturedCheckoutAttemptId = await this.service.requestCheckoutAttemptId(payload);\n\n            this.storage.set({\n                id: this.capturedCheckoutAttemptId,\n                timestamp: isSessionReusable ? checkoutAttemptIdSession.timestamp : Date.now()\n            });\n        } catch (error: unknown) {\n            this.enabled = false;\n            console.warn('Analytics: Error setting up', error);\n        }\n    }\n\n    public sendAnalytics(event: AbstractAnalyticsEvent): void {\n        if (!this.enabled) {\n            return;\n        }\n\n        try {\n            this.addEventToQueue(event);\n        } catch (error: unknown) {\n            console.warn('Analytics: Error adding event to queue', error);\n        }\n    }\n\n    public async sendFlavor(flavor: 'dropin' | 'components'): Promise<void> {\n        if (!this.capturedCheckoutAttemptId) return;\n        if (this.isFlavorReported) return;\n\n        this.isFlavorReported = true;\n\n        try {\n            await this.service.reportIntegrationFlavor(flavor, this.capturedCheckoutAttemptId);\n        } catch (error) {\n            console.warn('Analytics: Error reporting flavor', error);\n        }\n    }\n\n    public flush(): void {\n        void this.sendEvents();\n    }\n\n    /**\n     * Info events don't have high priority, therefore  we add a delay in order to dispatch a batch of events\n     * Log/Error events are sent almost immediately. There is a debounce mechanism in place but the delay is very minimal\n     *\n     * @param event\n     * @private\n     */\n    private addEventToQueue(event: AbstractAnalyticsEvent): void {\n        this.eventsQueue.add(event);\n\n        if (event.getEventCategory() === AnalyticsEventCategory.info) {\n            this.debouncedSendInfoEvents();\n        } else {\n            this.debouncedSendEvents();\n        }\n    }\n\n    private async sendEvents(): Promise<void> {\n        if (!this.capturedCheckoutAttemptId || !this.enabled) {\n            return;\n        }\n\n        const payload: AnalyticsEventPayload = {\n            channel: 'Web',\n            platform: 'Web',\n            info: this.eventsQueue.infoEvents,\n            errors: this.eventsQueue.errorEvents,\n            logs: this.eventsQueue.logEvents\n        };\n\n        this.eventsQueue.clear();\n\n        try {\n            await this.service.sendEvents(payload, this.capturedCheckoutAttemptId);\n        } catch (error) {\n            console.warn('Analytics: Error sending events', error);\n        }\n    }\n}\n\nexport default Analytics;\n"],"names":["Analytics","setUp","sessionId","checkoutStage","locale","checkoutAttemptIdSession","this","storage","get","isSessionReusable","session","timestamp","fifteenMinutesAgo","Date","now","isSessionCreatedUnderFifteenMinutes","applicationInfo","checkoutAttemptId","checkoutAttemptIdFromPayByLink","processAnalyticsData","analyticsData","availableCheckoutAttemptId","id","payload","version","LIBRARY_VERSION","buildType","LIBRARY_BUNDLE_TYPE","channel","platform","referrer","window","location","href","screenWidth","screen","width","level","enabled","capturedCheckoutAttemptId","service","requestCheckoutAttemptId","set","error","console","warn","sendAnalytics","event","addEventToQueue","sendFlavor","flavor","isFlavorReported","reportIntegrationFlavor","flush","sendEvents","eventsQueue","add","getEventCategory","AnalyticsEventCategory","info","debouncedSendInfoEvents","debouncedSendEvents","infoEvents","errors","errorEvents","logs","logEvents","clear","constructor","eventQueue","_define_property","Storage","debounce","bind","undefined"],"mappings":"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"}